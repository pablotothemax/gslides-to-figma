<!DOCTYPE html>
<html>
<head>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      color: #333;
      padding: 16px;
      min-height: 300px;
    }

    .screen {
      display: none;
    }

    .screen.active {
      display: block;
    }

    h2 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #1a1a1a;
    }

    p {
      color: #666;
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      width: 100%;
    }

    .btn-primary {
      background-color: #18A0FB;
      color: white;
    }

    .btn-primary:hover {
      background-color: #0d8de5;
    }

    .btn-primary:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .btn-google {
      background-color: #fff;
      color: #333;
      border: 1px solid #ddd;
    }

    .btn-google:hover {
      background-color: #f5f5f5;
    }

    .btn-secondary {
      background-color: #f0f0f0;
      color: #333;
    }

    .btn-secondary:hover {
      background-color: #e0e0e0;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 12px;
      margin-bottom: 12px;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #18A0FB;
      box-shadow: 0 0 0 2px rgba(24, 160, 251, 0.2);
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: #f5f5f5;
      border-radius: 6px;
      margin-bottom: 16px;
    }

    .user-info img {
      width: 24px;
      height: 24px;
      border-radius: 50%;
    }

    .user-info span {
      flex: 1;
      font-size: 11px;
      color: #666;
    }

    .user-info button {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 11px;
      text-decoration: underline;
    }

    .progress {
      margin-top: 16px;
    }

    .progress-bar {
      height: 4px;
      background: #e0e0e0;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: #18A0FB;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 11px;
      color: #666;
    }

    .error {
      background: #FEE;
      border: 1px solid #FCC;
      color: #C00;
      padding: 10px 12px;
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 11px;
    }

    .success {
      background: #EFE;
      border: 1px solid #CFC;
      color: #060;
      padding: 10px 12px;
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 11px;
    }

    .help-text {
      font-size: 11px;
      color: #999;
      margin-top: 8px;
    }

    .google-icon {
      width: 18px;
      height: 18px;
    }

    .divider {
      border-top: 1px solid #eee;
      margin: 16px 0;
    }
  </style>
</head>
<body>
  <!-- Screen 1: Authentication -->
  <div id="screen-auth" class="screen active">
    <h2>Import from Google Slides</h2>
    <p>Sign in with your Google account to access your presentations.</p>

    <div id="auth-error" class="error" style="display: none;"></div>

    <button id="btn-signin" class="btn btn-google">
      <svg class="google-icon" viewBox="0 0 24 24">
        <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
        <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
        <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
        <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
      </svg>
      Sign in with Google
    </button>

    <p class="help-text">Your credentials are used only to access your presentations. Nothing is stored.</p>
  </div>

  <!-- Screen 2: Import -->
  <div id="screen-import" class="screen">
    <h2>Import Presentation</h2>

    <div id="user-info" class="user-info">
      <img id="user-avatar" src="" alt="">
      <span id="user-email"></span>
      <button id="btn-signout">Sign out</button>
    </div>

    <div id="import-error" class="error" style="display: none;"></div>
    <div id="import-success" class="success" style="display: none;"></div>

    <input type="text" id="slides-url" placeholder="Paste Google Slides URL here...">

    <button id="btn-import" class="btn btn-primary">
      Import Slides
    </button>

    <div id="progress" class="progress" style="display: none;">
      <div class="progress-bar">
        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
      </div>
      <div id="progress-text" class="progress-text">Starting import...</div>
    </div>

    <p class="help-text">Supported: Text, shapes, images. Tables and charts may have reduced fidelity.</p>
  </div>

  <script>
    // ============================================
    // CONFIGURATION - Update these values
    // ============================================
    const OAUTH_WORKER_URL = 'https://gslides-to-figma.pablo-0f5.workers.dev';

    // State
    let accessToken = null;
    let userInfo = null;
    let authPopup = null;
    let authSessionId = null;
    let pollInterval = null;

    // DOM Elements
    const screenAuth = document.getElementById('screen-auth');
    const screenImport = document.getElementById('screen-import');
    const btnSignin = document.getElementById('btn-signin');
    const btnSignout = document.getElementById('btn-signout');
    const btnImport = document.getElementById('btn-import');
    const slidesUrlInput = document.getElementById('slides-url');
    const authError = document.getElementById('auth-error');
    const importError = document.getElementById('import-error');
    const importSuccess = document.getElementById('import-success');
    const progressDiv = document.getElementById('progress');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const userAvatar = document.getElementById('user-avatar');
    const userEmail = document.getElementById('user-email');

    // Generate random session ID
    function generateSessionId() {
      return 'sess_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
    }

    // Open OAuth popup
    function startAuth() {
      hideError(authError);

      // Generate unique session ID for this auth attempt
      authSessionId = generateSessionId();

      const width = 500;
      const height = 600;
      const left = (screen.width - width) / 2;
      const top = (screen.height - height) / 2;

      authPopup = window.open(
        `${OAUTH_WORKER_URL}/auth?session=${authSessionId}`,
        'google-auth',
        `width=${width},height=${height},left=${left},top=${top},menubar=no,toolbar=no,location=no,status=no`
      );

      // Start polling for token
      startTokenPolling();
    }

    // Poll for token from worker
    function startTokenPolling() {
      if (pollInterval) {
        clearInterval(pollInterval);
      }

      let pollCount = 0;
      const maxPolls = 120; // 2 minutes max (every 1 second)

      pollInterval = setInterval(async () => {
        pollCount++;

        // Check if popup was closed without completing
        if (authPopup && authPopup.closed) {
          // Give it a few more polls in case token is still being processed
          if (pollCount > 5) {
            clearInterval(pollInterval);
            pollInterval = null;
            authPopup = null;
            // Don't show error - user might have completed auth
          }
        }

        // Stop after max polls
        if (pollCount >= maxPolls) {
          clearInterval(pollInterval);
          pollInterval = null;
          if (!accessToken) {
            showError(authError, 'Authentication timed out. Please try again.');
          }
          return;
        }

        // Poll for token
        try {
          const response = await fetch(`${OAUTH_WORKER_URL}/token?session=${authSessionId}`);
          const data = await response.json();

          if (data.success && data.accessToken) {
            clearInterval(pollInterval);
            pollInterval = null;
            accessToken = data.accessToken;

            if (authPopup && !authPopup.closed) {
              authPopup.close();
            }
            authPopup = null;

            // Show loading state
            btnSignin.textContent = 'Signing in...';
            btnSignin.disabled = true;

            try {
              await fetchUserInfo();
            } catch (fetchErr) {
              showError(authError, 'Failed to complete sign in: ' + fetchErr.message);
              btnSignin.innerHTML = `<svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg> Sign in with Google`;
              btnSignin.disabled = false;
            }
          }
        } catch (err) {
          console.log('Poll error:', err);
        }
      }, 1000);
    }

    // Handle messages from plugin code (and fallback for postMessage from popup)
    window.addEventListener('message', async (event) => {
      // Handle messages from the OAuth popup (fallback, may not work)
      if (event.data.type === 'oauth-success' && event.data.accessToken && !accessToken) {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
        accessToken = event.data.accessToken;
        if (authPopup) {
          authPopup.close();
          authPopup = null;
        }
        await fetchUserInfo();
      } else if (event.data.type === 'oauth-error' && !accessToken) {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
        if (authPopup) {
          authPopup.close();
          authPopup = null;
        }
        showError(authError, 'Authentication failed: ' + event.data.error);
      }

      // Handle messages from plugin code
      const msg = event.data.pluginMessage;
      if (msg) {
        if (msg.type === 'progress') {
          updateProgress(msg.percent, msg.text);
        } else if (msg.type === 'complete') {
          hideProgress();
          showSuccess(`Successfully imported ${msg.slideCount} slides!`);
          btnImport.disabled = false;
        } else if (msg.type === 'error') {
          showError(importError, msg.message);
          hideProgress();
          btnImport.disabled = false;
        }
      }
    });

    async function fetchUserInfo() {
      try {
        const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`API error ${response.status}: ${errorText}`);
        }

        userInfo = await response.json();

        if (!userInfo || !userInfo.email) {
          throw new Error('Invalid user info received');
        }

        showImportScreen();
      } catch (err) {
        // Reset button state
        btnSignin.innerHTML = `<svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg> Sign in with Google`;
        btnSignin.disabled = false;
        accessToken = null;
        showError(authError, 'Failed to get user information: ' + err.message);
        throw err; // Re-throw so caller knows it failed
      }
    }

    function showImportScreen() {
      screenAuth.classList.remove('active');
      screenImport.classList.add('active');

      if (userInfo) {
        userAvatar.src = userInfo.picture || '';
        userEmail.textContent = userInfo.email || 'Signed in';
      }
    }

    function showAuthScreen() {
      screenImport.classList.remove('active');
      screenAuth.classList.add('active');
      accessToken = null;
      userInfo = null;
      hideError(authError);
    }

    function showError(element, message) {
      element.textContent = message;
      element.style.display = 'block';
    }

    function hideError(element) {
      element.style.display = 'none';
    }

    function showSuccess(message) {
      importSuccess.textContent = message;
      importSuccess.style.display = 'block';
    }

    function hideSuccess() {
      importSuccess.style.display = 'none';
    }

    function updateProgress(percent, text) {
      progressDiv.style.display = 'block';
      progressFill.style.width = percent + '%';
      progressText.textContent = text;
    }

    function hideProgress() {
      progressDiv.style.display = 'none';
    }

    function extractPresentationId(url) {
      // Handle various Google Slides URL formats
      const patterns = [
        /\/presentation\/d\/([a-zA-Z0-9-_]+)/,
        /\/d\/([a-zA-Z0-9-_]+)/,
        /^([a-zA-Z0-9-_]+)$/
      ];

      for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
      }

      return null;
    }

    async function fetchPresentation(presentationId) {
      const response = await fetch(
        `https://slides.googleapis.com/v1/presentations/${presentationId}`,
        {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        }
      );

      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new Error(error.error?.message || 'Failed to fetch presentation');
      }

      return response.json();
    }

    async function fetchImageAsBase64(url) {
      try {
        // For Google-hosted images, we need to fetch with auth
        const response = await fetch(url, {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        });

        if (!response.ok) {
          // Try without auth for public images
          const publicResponse = await fetch(url);
          if (!publicResponse.ok) return null;
          const blob = await publicResponse.blob();
          return await blobToBase64(blob);
        }

        const blob = await response.blob();
        return await blobToBase64(blob);
      } catch (err) {
        console.error('Failed to fetch image:', err);
        return null;
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function importSlides() {
      hideError(importError);
      hideSuccess();

      const url = slidesUrlInput.value.trim();
      if (!url) {
        showError(importError, 'Please enter a Google Slides URL');
        return;
      }

      const presentationId = extractPresentationId(url);
      if (!presentationId) {
        showError(importError, 'Invalid Google Slides URL. Please paste a valid URL.');
        return;
      }

      btnImport.disabled = true;
      updateProgress(5, 'Fetching presentation...');

      try {
        const presentation = await fetchPresentation(presentationId);
        updateProgress(15, 'Processing slides...');

        const slides = presentation.slides || [];
        const pageSize = presentation.pageSize;

        // Process slides and collect image URLs
        const processedSlides = [];
        const imageUrls = new Set();

        for (let i = 0; i < slides.length; i++) {
          const slide = slides[i];
          const elements = processSlideElements(slide.pageElements || []);

          // Collect image URLs
          elements.forEach(el => {
            if (el.type === 'image' && el.imageUrl) {
              imageUrls.add(el.imageUrl);
            }
          });

          processedSlides.push({
            index: i,
            elements: elements
          });
        }

        updateProgress(30, 'Fetching images...');

        // Fetch all images
        const imageData = {};
        const imageUrlArray = Array.from(imageUrls);
        for (let i = 0; i < imageUrlArray.length; i++) {
          const url = imageUrlArray[i];
          const base64 = await fetchImageAsBase64(url);
          if (base64) {
            imageData[url] = base64;
          }
          updateProgress(30 + (i / imageUrlArray.length) * 30, `Fetching image ${i + 1} of ${imageUrlArray.length}...`);
        }

        updateProgress(60, 'Creating Figma frames...');

        // Send to plugin code
        parent.postMessage({
          pluginMessage: {
            type: 'import-slides',
            presentation: {
              title: presentation.title,
              pageSize: pageSize,
              slides: processedSlides
            },
            imageData: imageData
          }
        }, '*');

      } catch (err) {
        showError(importError, err.message);
        hideProgress();
        btnImport.disabled = false;
      }
    }

    function processSlideElements(pageElements) {
      const elements = [];

      for (const element of pageElements) {
        const processed = processElement(element);
        if (processed) {
          elements.push(processed);
        }
      }

      return elements;
    }

    function processElement(element) {
      const transform = element.transform || {};
      const size = element.size || {};

      // Convert EMU to pixels (914400 EMU = 1 inch, 72 pixels = 1 inch)
      const emuToPixels = (emu) => (emu || 0) / 914400 * 72;

      const baseProps = {
        x: emuToPixels(transform.translateX),
        y: emuToPixels(transform.translateY),
        width: emuToPixels(size.width?.magnitude),
        height: emuToPixels(size.height?.magnitude),
        scaleX: transform.scaleX || 1,
        scaleY: transform.scaleY || 1,
        rotation: Math.atan2(transform.shearY || 0, transform.scaleX || 1) * (180 / Math.PI)
      };

      // Handle shape with text
      if (element.shape) {
        const shape = element.shape;
        const shapeType = shape.shapeType || 'RECTANGLE';

        // Get fill color
        let fillColor = null;
        if (shape.shapeProperties?.shapeBackgroundFill?.solidFill) {
          fillColor = convertColor(shape.shapeProperties.shapeBackgroundFill.solidFill.color);
        }

        // Get outline
        let strokeColor = null;
        let strokeWeight = 0;
        if (shape.shapeProperties?.outline?.outlineFill?.solidFill) {
          strokeColor = convertColor(shape.shapeProperties.outline.outlineFill.solidFill.color);
          strokeWeight = emuToPixels(shape.shapeProperties.outline.weight?.magnitude) || 1;
        }

        // Process text content
        let textContent = null;
        if (shape.text) {
          textContent = processTextContent(shape.text);
        }

        return {
          ...baseProps,
          type: 'shape',
          shapeType: shapeType,
          fillColor: fillColor,
          strokeColor: strokeColor,
          strokeWeight: strokeWeight,
          text: textContent
        };
      }

      // Handle image
      if (element.image) {
        const image = element.image;
        let imageUrl = image.contentUrl || image.sourceUrl;

        return {
          ...baseProps,
          type: 'image',
          imageUrl: imageUrl
        };
      }

      // Handle table (simplified)
      if (element.table) {
        const table = element.table;
        const rows = [];

        if (table.tableRows) {
          for (const row of table.tableRows) {
            const cells = [];
            if (row.tableCells) {
              for (const cell of row.tableCells) {
                let cellText = '';
                if (cell.text) {
                  const textContent = processTextContent(cell.text);
                  cellText = textContent.runs.map(r => r.text).join('');
                }
                cells.push(cellText);
              }
            }
            rows.push(cells);
          }
        }

        return {
          ...baseProps,
          type: 'table',
          rows: rows,
          rowCount: table.rows || 0,
          columnCount: table.columns || 0
        };
      }

      // Handle line
      if (element.line) {
        const line = element.line;
        let strokeColor = { r: 0, g: 0, b: 0 };
        let strokeWeight = 1;

        if (line.lineProperties?.lineFill?.solidFill) {
          strokeColor = convertColor(line.lineProperties.lineFill.solidFill.color);
        }
        if (line.lineProperties?.weight?.magnitude) {
          strokeWeight = emuToPixels(line.lineProperties.weight.magnitude);
        }

        return {
          ...baseProps,
          type: 'line',
          strokeColor: strokeColor,
          strokeWeight: strokeWeight
        };
      }

      // Handle groups
      if (element.elementGroup) {
        const children = [];
        if (element.elementGroup.children) {
          for (const child of element.elementGroup.children) {
            const processed = processElement(child);
            if (processed) {
              children.push(processed);
            }
          }
        }

        return {
          ...baseProps,
          type: 'group',
          children: children
        };
      }

      return null;
    }

    function processTextContent(text) {
      const runs = [];

      if (text.textElements) {
        for (const textElement of text.textElements) {
          if (textElement.textRun) {
            const run = textElement.textRun;
            const style = run.style || {};

            // Get font info
            let fontFamily = style.fontFamily || 'Arial';
            let fontSize = 14;
            if (style.fontSize?.magnitude) {
              fontSize = style.fontSize.magnitude * (style.fontSize.unit === 'PT' ? 1 : 1);
            }

            // Determine font weight and style
            let fontWeight = style.bold ? 700 : 400;
            let fontStyle = style.italic ? 'italic' : 'normal';

            // Get text color
            let textColor = { r: 0, g: 0, b: 0 };
            if (style.foregroundColor?.opaqueColor) {
              textColor = convertColor(style.foregroundColor.opaqueColor);
            }

            runs.push({
              text: run.content || '',
              fontFamily: fontFamily,
              fontSize: fontSize,
              fontWeight: fontWeight,
              fontStyle: fontStyle,
              color: textColor,
              underline: style.underline || false,
              strikethrough: style.strikethrough || false
            });
          }
        }
      }

      return { runs: runs };
    }

    function convertColor(color) {
      if (!color) return { r: 0, g: 0, b: 0 };

      if (color.rgbColor) {
        return {
          r: color.rgbColor.red || 0,
          g: color.rgbColor.green || 0,
          b: color.rgbColor.blue || 0
        };
      }

      // Handle theme colors (return a default)
      if (color.themeColor) {
        // Common theme color mappings
        const themeColors = {
          'DARK1': { r: 0, g: 0, b: 0 },
          'LIGHT1': { r: 1, g: 1, b: 1 },
          'DARK2': { r: 0.2, g: 0.2, b: 0.2 },
          'LIGHT2': { r: 0.9, g: 0.9, b: 0.9 },
          'ACCENT1': { r: 0.26, g: 0.52, b: 0.96 },
          'ACCENT2': { r: 0.92, g: 0.26, b: 0.21 },
          'ACCENT3': { r: 0.98, g: 0.74, b: 0.02 },
          'ACCENT4': { r: 0.13, g: 0.59, b: 0.33 },
          'ACCENT5': { r: 1, g: 0.43, b: 0 },
          'ACCENT6': { r: 0.4, g: 0.23, b: 0.72 },
        };
        return themeColors[color.themeColor] || { r: 0.5, g: 0.5, b: 0.5 };
      }

      return { r: 0, g: 0, b: 0 };
    }

    // Event listeners
    btnSignin.addEventListener('click', startAuth);

    btnSignout.addEventListener('click', () => {
      showAuthScreen();
    });

    btnImport.addEventListener('click', importSlides);
  </script>
</body>
</html>
